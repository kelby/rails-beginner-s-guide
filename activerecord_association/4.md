# 4 个关联类方法

Rails 提供了 4 个类方法，用于声明对象与对象之间的关系。它们的意思，理解起来很简单，和字面意思一样，如"Project has one Project Manager" 或 "Project belongs to a Portfolio".   但实际使用过程，还是有很多要注意的。不同的场景，需要不同的参数；并且，它们会引入一些额外的方法，有的和 attr_* 类似，但有的不是。

```ruby
class Project < ActiveRecord::Base
  belongs_to              :portfolio
  has_one                 :project_manager
  has_many                :milestones
  has_and_belongs_to_many :categories
end
```

上面例子里的场景最简单，不需要带任何参数；下面是它们引入的额外的方法，包括但不限于：

```ruby
# 1
Project#portfolio, Project#portfolio=(portfolio), Project#portfolio.nil?

# 2
Project#project_manager, Project#project_manager=(project_manager), Project#project_manager.nil?,

# 3
Project#milestones.empty?, Project#milestones.size, Project#milestones, Project#milestones<<(milestone), Project#milestones.delete(milestone), Project#milestones.destroy(milestone), Project#milestones.find(milestone_id), Project#milestones.build, Project#milestones.create

# 4
Project#categories.empty?, Project#categories.size, Project#categories, Project#categories<<(category1), Project#categories.delete(category1), Project#categories.destroy(category1)
```

## 1) belongs_to

### 方法本身表示什么意思。

指定一对一关系。如果，"前者 belongs_to 后者"，那么'前者'需要包括'后者_id'属性。

### 引进了哪些方法，表示什么意思。

|方法|解释|
|--|--|
|association(force_reload = false)|类似 attr_reader. 如果没有的话，返回 nil.|
|association=(associate)|类似 attr_writer.|
|build_association(attributes = {})|构建并返回后者。这里后者还未保存在数据库。|
|create_association(attributes = {})|创建并返回后者。这里后者会被保存在数据库(如果校验没有问题的话)|
|create_association!(attributes = {})|和 create_association 类似, 但如果创建失败会报错 ActiveRecord::RecordInvalid.|

后面几个方法，作用类似，只是细节部分有所不同，使用时注意一下即可。

### 有什么参数，表示什么意思，使用后有什么效果。

普通参数 **Scope**

设置一个 scope，通过前者查询后者的时候(其它时候不影响)，自动加到查询语句里。(类似在后者 model 里定义了一个 default_scope，但只有通过前者查询才起作用)

举例:

```ruby
belongs_to :user, -> { where(id: 2) }
belongs_to :user, -> { joins(:friends) }
belongs_to :level, ->(level) { where("game_level > ?", level.current) }
```

可选参数 **Options**

| 参数 | 解释 |
| -- | -- |
| :class_name | 后者对应着一个 model. 当按照"约定"找不到这个 model 的时候，用 :class_name 指明。|
| :foreign_key | 前者包含了"后者_id"属性，这个属性是按照"约定"命名的，如果不符合"约定"，用 :foreign_key 指明。|
| :foreign_type | 多态时，前者同时包含"后者_id"和"后者_type"属性。当"后者_type"不符合"约定"时，用 :foreign_type 指明。|
| :primary_key | 凡是通过前者查询后者 - "前者.后者"。默认"后者_id"属性对应着后者的 id 属性，如果觉得不合适，可以用 :primary_key 指明。|
| :dependent | 如果设置为 :destroy, 前者被删除时，后者也会同时被 destroy. 如果设置为 :delete, 前者被删除时，后者也会同时被 delete. |
| :counter_cache | 设置为 true 后，创建或删除一个前者，会相应的调用 increment_counter 或 decrement_counter 来改变后者计数器的值。默认是 false，也就是不起作用。|
| :polymorphic | 声明 belongs_to 关联是多态的。|
| :validate | 设置为 true, 保存后者的时候会先对所有前者进行校验。默认是 false, 也就是不起作用。|
| :autosave | 设置为 true, 保存后者时会自动保存所有前者，destroy 后者时会自动删除所有前者。设置为 false 还可分为两种情况：前者为 new_record，则保存后者时会自动保存前者；否则上述自动操作都不会被执行。|
| :touch | 设置为 true, 保存或 destroy 前者的时候，后者的 updated_at/on 属性会被设置成当前时间。|
| :inverse_of | 保证 object_id 相同。通过前者(1)查询到后者，然后再通过后者返过来查询前者(2)。按照直观的理解，(1) 和 (2) 应该是同样的对象，同样的值。但实际情况会发现，它们不一样(可以通过 object_id 确定)！原因是程序没有这么聪明，没法判断它们是一样的(特别是通过中间表查询时)。设置 :inverse_of，可解决这个问题。|
| :required | 语法糖。原来的做法是 "belongs_to 后者" + "validates_presence_of 后者"，现改为 "belongs_to 后者, required: true"|

### 注意事项。

- 前者包含了"后者_id"属性，注意和下文提到的 has_one 的区别。
- `:class_name` 不影响 `:foreign_key` "后者_id"属性的命名约定。
- 当后者与前者的关系是 has_many 时，请慎用 `:dependent`. 因为后者被同时删除的话，剩下的前者将成为孤儿(没有前者可关联)。
- `:counter_cache` 计数器是根据"前者对应的 table_name + count"生成的，如里不符合"约定"，可以用 :counter_cache 指明。自定义计数器名字的时候，建议把此属性声明为 attr_readonly. 综上，:counter_cache 可以设置为 true、false、或自定义的名字。
- `:polymorphic` 如果你同时使用了 `:counter_cache`，建议在后者的 model 里把计数器设置为 attr_readonly.
- 综上两条注意事项，有两种情况建议在后者的 model 里手动把计数器设置为 attr_readonly.
- `:validate` 对于是否是 new_record 在做 valid? 时，会造成迷惑。牢记，`:validate` 意味着对前者和后者都有"保存"操作。如果校验失败，则本次保存失败。
- `:autosave` 如果在 model 里使用了 accepts_nested_attributes_for，则对应 `:autosave` 始终为 true.
- `:touch` 如果你不是设置成 true, 而是传递一个符号 :symbol，那么这个符号会被更新为当前时间。
- `:inverse_of` 带来额外的好处：1. 不用重复查询，节省了性能；2. 因为对象的 object_id 都是一样的，保证了数据一致性；需要注意：第 2 次"查询"不是数据库查询，会存在操作脏数据的风险。
- `:inverse_of` 通常情况下，不用设置，会自动转换。但使用了以下参数，则不会自动转换：:through、:as、:polymorphic 和 :conditions
- `:required` "validates_presence_of 后者" 和 "validates_presence_of 后者_id" 大同小异。

## 2) has_one

### 方法本身表示什么意思。

指定一对一关系。如果，"前者 has_one 后者"，那么'后者'需要包括'前者_id'属性。

### 引进了哪些方法，表示什么意思。

| 方法 | 解释 |
| -- | -- |
| association(force_reload = false) | 类似 attr_reader. 如果没有的话，返回 nil. |
| association=(associate) | 类似 attr_writer. |
| build_association(attributes = {}) | 构建并返回后者。这里后者还未保存在数据库。 |
| create_association(attributes = {}) | 创建并返回后者。这里后者会被保存在数据库(如果校验没有问题的话) |
| create_association!(attributes = {}) | 和 create_association 类似, 但如果创建失败会报错 ActiveRecord::RecordInvalid. |

这里的解释参考了 `belongs_to`，不单它们的方法名是一样的。定们定义方法时也是一样的，参考 Association.define_accessors 和 SingularAssociation.define_constructors

另，belongs_to 和 has_one 都属于 SingularAssociation.

### 有什么参数，表示什么意思，使用后有什么效果。

普通参数 **Scope**

设置一个 scope，通过前者查询后者的时候(其它时候不影响)，自动加到查询语句里。(类似在后者 model 里定义了一个 default_scope，但只有通过前者查询才起作用)

举例:

```ruby
has_one :author, -> { where(comment_id: 1) }
has_one :employer, -> { joins(:company) }
has_one :dob, ->(dob) { where("Date.new(2000, 01, 01) > ?", dob) }
```

可选参数 **Options**

| 参数 | 解释 |
| -- | -- |
| :class_name | 参考 belongs_to 的解释 |
| :dependent | 删除前者时，对后者进行什么操作。1) :destroy, 删除后者，会触发回调；2) :delete, 删除后者，不会触发回调；3) ::nullify, 把后者里的"前者_id"属性设置为 nil, 不会触发回调；4) :restrict_with_exception, 如果有后者的关联对象，报异常；5) :restrict_with_error 如果有后者的关联对象，报错。|
| :foreign_key | 后者包含了"前者_id"属性，这个属性是按照"约定"命名的，如果不符合"约定"，用 :foreign_key 指明。 |
| :primary_key | 凡是通过前者查询后者 - "前者.后者"。默认"后者_id"属性对应着后者的 id 属性，如果觉得不合适，可以用 :primary_key 指明。 |
| :as | 多态时用到，声明多态的接口。通常和 belongs_to 里的 :polymorphic 配对使用。|
| :through | 指定中间表。优先级比 :class_name、:primary_key 和 :foreign_key 要高。|
| :source | 中间表关联着前者和后者，并且"前者.后者"可拆分成1)"前者.中间表"，2)"中间表.后者"。第 1 步一般不会有误，但如果后者名字不规范，那么在第 2 步"中间表.后者"就会走不下去。用 :source 明确后者对应中间表里的什么关联。|
| :source_type | 从后者的角度来看，后者与前者的关联应该是 belongs_to. 但如果恰好又是多态，那么后者保存有前者的 id 并指定某个类型. 如果你对按约定生成的类型不满意，可以用 :source_type 指明。|
| :validate | 设置为 false, 保存前者时不会校验后者。默认就是 false.|
| :autosave | 参考 belongs_to 的解释 |
| :inverse_of | 参考 belongs_to 的解释 |
| :required | 参考 belongs_to 的解释 |

### 注意事项。

- `:through` 实现关联时用到了 reflection 的代码，所以 has_one 或 belongs_to 关联要使用中间表，只能通过 :through 这一种方式，区别于 has_many :through 和 has_and_belongs_to_many.
- `:source_type` 影响的是数据，不是属性。

## 3) has_many

### 方法本身表示什么意思。

指定一对多关系。

### 引进了哪些方法，表示什么意思。

| 方法 | 解释 |
| -- | -- |
| collection(force_reload = false) | 类似 attr_reader. 如果没有的话返回一个空的 Relation (类似空数组).|
| collection<<(object, …) | 设置后者的"前者_id"属性的值为"前者.id"，即可将后者与前者关联起来。只要前者非 new_record，此操作立即生效。一个前者可以关联多个后者，这里是追加操作，也就是说关联数量会增加。|
| collection.delete(object, …) | 设置后者的"前者_id"属性的值为 nil，即可解除前者与后者的关联，这里只是更新(不是删除)。设置可选参数 dependent: :destroy, 则后者会被 destroy; 设置可选参数 dependent: :delete_all, 则后者会被 delete. <br> 如果设置了可选参数 :through, 则关联表'默认'会被删除(不是更新)，这里用'默认'，说明可配置。|
| collection.destroy(object, …) | destroy 后者，这里优先级大于可选参数 :dependent，并且这里会触发回调。 <br> 如果设置了可选参数 :through, 则关联表'立即'会被删除(不是更新)，这里用'立即'，说明不可配置。|
| collection=objects | 设置后者与前者的关联。一个前者可以关联多个后者，这里包含增加、删除操作，也就是说关联数量可增加、减少或不变。此操作是"<<" 和 "delete"操作的结合版本。<br> 如果设置了可选参数 :through, 则关联表'立即'会被增加或删除(不是更新)。|
| collection_singular_ids | 返回所有关联后者的 id.|
| collection_singular_ids=ids | 类似 collection= 只不过这里传递的是 id.|
| collection.clear | 移除关联的后者，这里是移除关联，不是删除。**除非** 设置了 dependent: :destroy 则后者会被 destroy; 设置了 dependent: delete_all 则后者被被 delete. <br> 如果设置了可选参数 :through, 则关联表'立即'会被删除(不是更新)。|
| collection.empty? | 如果没有关联对象，返回 true |
| collection.size | 返回关联对象的数目 |
| collection.find(…) | 从关联对象里查找对象，和 ActiveRecord::Base.find 一样。|
| collection.exists?(…) | 检测某个关联对象是否存在。和 ActiveRecord::Base.exists? 一样。 |
| collection.build(attributes = {}, …) | 创建一个或多个关联对象，这里已经设置了"前者_id"属性的值，但还没有保存到数据库。 |
| collection.create(attributes = {}) | 创建一个或多个关联对象，这里已经设置了"前者_id"属性的值，并且已经保存到了数据库  (前提是通过校验)。<br> 使用这个方法，有个前提条件，前者不能是 new_record. |
| collection.create!(attributes = {}) | 类似 collection.create, 但保存失败的话会报错 ActiveRecord::RecordInvalid |

以上解释，参考了官方文档。但因为各个参数组合起来，呈几何倍数的增长，验证过程难免有疏漏，实际情况以运行结果为准。

### 有什么参数，表示什么意思，使用后有什么效果。

普通参数 **Scope**

设置一个 scope，通过前者查询后者的时候(其它时候不影响)，自动加到查询语句里。(类似在后者 model 里定义了一个 default_scope，但只有通过前者查询才起作用)

举例:

```ruby
has_many :comments, -> { where(author_id: 1) }
has_many :employees, -> { joins(:address) }
has_many :posts, ->(post) { where("max_post_length > ?", post.length) }
```

普通参数 **Extension**

前面提到过，使用这几个关联方法时，"它们会引入一些额外的方法"，并且上文已经介绍了它们。但如果我们想要引入自己的方法，并且用途基本一样，要怎么做，可以用 Extension.

举例:

```ruby
class Organization < ActiveRecord::Base
  has_many :people do
    def find_active
      find(:all, :conditions => ["active = ?", true])
    end
  end
end
```

现在，可以用 `organization.people.find_active` 对后者进行操作。这样定义的方法，和 CollectionProxy 定义的方法类似。

> Note: 这些 Extension 方法，类似在后者 model 里定义的 scope, 但只能通过前者.后者这种方法调用！

可选参数 **Options**

| 参数 | 解释 |
| -- | -- |
| :class_name | 解释同上 |
| :foreign_key | 解释同上 |
| :primary_key | 解释同上 |
| :dependent | Controls what happens to the associated objects when their owner is destroyed. Note that these are implemented as callbacks, and Rails executes callbacks in order. Therefore, other similar callbacks may affect the :dependent behavior, and the :dependent behavior may affect other callbacks. |
| :counter_cache | This option can be used to configure a custom named :counter_cache. You only need this option, when you customized the name of your :counter_cache on the belongs_to association. |
| :as | 解释参考 belongs_to |
| :through | Specifies an association through which to perform the query. This can be any other type of association, including other :through associations. Options for :class_name, :primary_key and :foreign_key are ignored, as the association uses the source reflection. <br> If the association on the join model is a belongs_to, the collection can be modified and the records on the :through model will be automatically created and removed as appropriate. Otherwise, the collection is read-only, so you should manipulate the :through association directly. <br> If you are going to modify the association (rather than just read from it), then it is a good idea to set the :inverse_of option on the source association on the join model. This allows associated records to be built which will automatically create the appropriate join model records when they are saved. (See the 'Association Join Models' section above.) |
| :source | Specifies the source association name used by has_many :through queries. Only use it if the name cannot be inferred from the association. has_many :subscribers, through: :subscriptions will look for either :subscribers or :subscriber on Subscription, unless a :source is given. |
| :source_type | 从后者的角度来看，后者与前者的关联应该是 belongs_to. 但如果恰好又是多态，那么后者保存有前者的 id 并指定某个类型. 如果你对按约定生成的类型不满意，可以用 :source_type 指明。 |
| :validate | 同上。但默认是 true |
| :autosave | If true, always save the associated objects or destroy them if marked for destruction, when saving the parent object. If false, never save or destroy the associated objects. By default, only save associated objects that are new records. This option is implemented as a before_save callback. Because callbacks are run in the order they are defined, associated objects may need to be explicitly saved in any user-defined before_save callbacks. <br> Note that accepts_nested_attributes_for sets :autosave to true. |
| :inverse_of | 解释同上 |

### 注意事项。

- :dependent 可选参数
  - :destroy 删除(destroy)所有被关联对象。

  - :delete_all 和 destroy 类似，也是删除所有被关联对象。但区别在于，此删除操作不会触发回调。

  - :nullify 设置后者的"前者_id"属性为 nil. 不会触发回调。

  - :restrict_with_exception causes an exception to be raised if there are any associated records.

  - :restrict_with_error causes an error to be added to the owner if there are any associated objects.

If using with the :through option, the association on the join model must be a belongs_to, and the records which get deleted are the join records, rather than the associated records.


## 4) has_and_belongs_to_many

### 方法本身表示什么意思。

指定多对多关系。用中间表来连接前者与后者。如果没有明确的指定中间表的名字，那么默认按前者、后者的字母顺序排序构成中间表。

### 引进了哪些方法，表示什么意思。

| 方法 | 解释 |
| -- | -- |
| collection(force_reload = false) | 解释同上 |
| collection<<(object, …) | 解释同上 |
| collection.delete(object, …) | 解释同上 |
| collection.destroy(object, …) | 解释同上。但不会删除对象，只会删除连接表。 |
| collection=objects | Replaces the collection's content by deleting and adding objects as appropriate. |
| collection_singular_ids | Returns an array of the associated objects' ids. |
| collection_singular_ids=ids | Replace the collection by the objects identified by the primary keys in ids. |
| collection.clear | 移除关联，也就是中间表数据。并没有删除后者。|
| collection.empty? | 解释同上 |
| collection.size | 解释同上 |
| collection.find(id) | 解释同上 |
| collection.exists?(…) | 解释同上 |
| collection.build(attributes = {}) | 解释同上 |
| collection.create(attributes = {}) | 解释同上 |

### 有什么参数，表示什么意思，使用后有什么效果。

普通参数 **Scope**

设置一个 scope，通过前者查询后者的时候(其它时候不影响)，自动加到查询语句里。(类似在后者 model 里定义了一个 default_scope，但只有通过前者查询才起作用)

举例:

```ruby
has_and_belongs_to_many :projects, -> { includes :milestones, :manager }
has_and_belongs_to_many :categories, ->(category) {
  where("default_category = ?", category.name)
}
```

普通参数 **Extension**

前面提到过，使用这几个关联方法时，"它们会引入一些额外的方法"，并且上文已经介绍了它们。但如果我们想要引入自己的方法，并且用途基本一样，要怎么做，可以用 Extension.

举例:

```ruby
has_and_belongs_to_many :contractors do
  def find_or_create_by_name(name)
    first_name, last_name = name.split(" ", 2)
    find_or_create_by(first_name: first_name, last_name: last_name)
  end
end
```

现在，可以用 `organization.people.find_active` 对后者进行操作。这样定义的方法，和 CollectionProxy 定义的方法类似。

> Note: 这些 Extension 方法，类似在后者 model 里定义的 scope, 但只能通过前者.后者这种方法调用！

可选参数 **Options**

| 参数 | 解释 |
| -- | -- |
| :class_name | 同上 |
| :join_table | Specify the name of the join table if the default based on lexical order isn't what you want. **WARNING:** If you're overwriting the table name of either class, the table_name method MUST be declared underneath any has_and_belongs_to_many declaration in order to work. |
| :foreign_key | 同上 |
| :association_foreign_key | Specify the foreign key used for the association on the receiving side of the association. By default this is guessed to be the name of the associated class in lower-case and “_id” suffixed. So if a Person class makes a has_and_belongs_to_many association to Project, the association will use “project_id” as the default :association_foreign_key. |
| :readonly | 设置为 true, 通过前者查询到的后者限制为只读状态，不可更改。但其它方式查询出来的，不受此限制。|
| :validate | 解释同上。但默认为 true |
| :autosave | 解释同上 |

### 注意事项。

- 注意前者与后者的顺序比较方法，如果前几个字符一样，则往后一个个字符比较，如 “paper_boxes” 和 “papers” 生成的中间表名字是 “paper_boxes_papers” 而不是 “papers_paper_boxes”. 
- 你可以用可选参数 :join_table 指定中间表名字
- 如果前者和后者使用的表名都带有前缀并且还相同，那么中间表的名字也用同样的前缀，剩余部分用再按字母顺序排序。如：“catalog_categories” 和 “catalog_products” 生成的中间表是 “catalog_categories_products”.

## 其它

注意：可选参数 :dependent 在 has_one 和 belongs_to 里，删除关联用的是 delete；而在 has_many 里，删除关联用的是 delete_all.
这两者要做的事性质上是一样的，但请注意这点区别，并且它们都没有 destroy_all.

上述对方法或参数的解释，仅供参考，实际情况以运行结果为准。

当不确定参数表示什么意思，使用后有什么效果时，请慎用，可以选择其它确定/有把握的方法代替。

> Note: 当你不确定时，不妨多敲几行代码，以妨万一。
