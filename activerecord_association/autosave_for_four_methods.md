## 关联方法的 autosave 汇总

自动保存列表

| 方法| 新、新 | 新、旧 | 旧、新 | 旧、旧(未关联) | 旧、旧(已关联)|
| --  | :--:     | :--:     | :--:     | :--:     | :--: |
| has_one | √  |  √      |  X     |  X      | X |
| belongs_to | √ |  √ |  X | X |  X |
| has_many | √  | √ | X |  X | X |
| has_and_belongs_to_many |√ | X |  X | X | X |

添加 autosave: true 后

| 方法| 新、新 | 新、旧 | 旧、新 | 旧、旧(未关联) | 旧、旧(已关联)|
| --  | :--:     | :--:     | :--:     | :--:     | :--: |
| has_one | √  |  √      |  √     |  √      | X  |
| belongs_to | √ |  √ |  √ | √ |  X |
| has_many | √  | √ | √ |  √ | X |
| has_and_belongs_to_many |√ | X |  √ | √ | √ |

保存前者，自动保存后者。

要在同一"内存"下，才能更新后者。

autosave 时会不会对数据校验，如何校验？不会，保存关联对象用的是 before_save 实现。

-----

我上面理解错了
1. 没有把加关联、自动保存、加关联并自动保存区分开来
2. 自动保存只会保存关联对象(不论是否已经持久化)。

已经关联

前者已经持久化&后者已经持久化 | 前者已经持久化、后者没有 | 前者没有持久化、后者已经持久化 | 两者都还没有持久化 |

---

注意：声明 autosave 为 true，声明 autosave 为 false，以及不对 autosave 不做任何声明，这是 3 种情况。

子对象默认是有校验的，校验出错的话，错误信息会放在父对象身上。

使用 validation: false 可以不做此校验。

不声明 autosave 为 true 还是 false，只有当子对象为新对象才会自动保存。

使用 autosave 保存父对象时，子对象也会被保存，而不区分它们是否是新对象。

默认情况下，新、新，旧、新，新、旧 对于 has_one 会自动保存；旧、旧 对于 has_one 不会自动保存。

默认情况下，新、新，旧、新 对于 belongs_to 会自动保存；新、旧，旧、旧 对于 belongs_to 不会自动保存。

默认情况下，新、新，旧、新，新、旧 对于 has_many 会自动保存；旧、旧 对于 has_many 不会自动保存。

----

与相关的是 AutosaveAssociation
