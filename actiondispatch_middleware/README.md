# ActionDispatch Middleware

已经进入 Rails, 但还没正式进入我们应用，这时候需要做一些事。

Web 服务器已经处理过，转发过来了。做一些什么事呢？看一看下面的 middleware 都提供了什么功能就知道了。

下面只是做简介，详情可以查看 API 说明，或阅读源代码。

**Static**

从硬盘里直接返回静态文件内容。

如果移除此 middleware，则处理方式和普通请求一样，由路由决定转发到哪。

默认这些静态文件存放在 `public/` 目录下，如果找不到文件，则处理方式和普通请求一样，由路由决定转发到哪。

其它特点：自动校验文件路径，不能用于目录遍历等。

**~~MiddlewareStack~~**

**~~SSL~~**

**ShowExceptions**

程序抛异常时，如何处理。默认显示错误页面。相关 HTTP response 是 X-Cascade 标识。

**RequestId**

为每个用户的请求生成唯一的 X-Request-Id,  可以在防火墙、负载均衡、Web服务器之间传递。可用于跟踪用户，方便日志处理；或查看请求在集群中哪台机器上处理。

Rails 里可通过 `request.uuid` 查看，相关 HTTP header 是 X-Request-Id 标识。

根据经验，实际项目中可以考虑将此 middleware 移除。

**RemoteIp**

可用于防止IP伪造。

相关 HTTP header 是 X-Forwarded-For (XFF) 标识。

鉴于伪造这一字段非常容易，实际项目中可以考虑将此 middleware 移除。

**Reloader**

ActionDispatch::Reloader 在开发环境下，负责开路和扫尾工作，目的就是为了让我们的程序重新加载的速度更快。

ActionDispatch::Reloader 默认只在开发环境下启用，对应 `config.cache_classes = false`

**PublicExceptions**

程序抛异常时，负责'渲染'错误页面这个工作。默认从 `public/` 目录中寻找对应的异常文件，如 500 则渲染 `/public/500.html`

**~~ParamsParser~~**

**Flash**

获取 flash 内容。详情查看"Flash"章节

**~~ExceptionWrapper~~**

**DebugExceptions**

负责在开发环境下，在页面上输出日志和 debug 信息。

**Cookies**

可以通过 ActionController#cookies 读/写 cookies 数据。

写:

```ruby
# Sets a simple session cookie.
# This cookie will be deleted when the user's browser is closed.
cookies[:user_name] = "david"

# Cookie values are String based. Other data types need to be serialized.
cookies[:lat_lon] = JSON.generate([47.68, -122.37])

# Sets a cookie that expires in 1 hour.
cookies[:login] = { value: "XJ-122", expires: 1.hour.from_now }

# Sets a signed cookie, which prevents users from tampering with its value.
# The cookie is signed by your app's `secrets.secret_key_base` value.
# It can be read using the signed method `cookies.signed[:name]`
cookies.signed[:user_id] = current_user.id

# Sets a "permanent" cookie (which expires in 20 years from now).
cookies.permanent[:login] = "XJ-122"

# You can also chain these methods:
cookies.permanent.signed[:login] = "XJ-122"
```

读:

```ruby
cookies[:user_name]           # => "david"
cookies.size                  # => 2
JSON.parse(cookies[:lat_lon]) # => [47.68, -122.37]
cookies.signed[:login]        # => "XJ-122"
```
  
删除:

```ruby
cookies.delete :user_name
```

**Callbacks**

`before_call、after_call` 可以在请求转发(request dispatch)前后执行一些回调方法。

**Session**

包括 CacheStore && CookieStore && MemCacheStore

用得最多，并且默认的是 CookieStore.

This cookie-based session store is the Rails default. It is
  dramatically faster than the alternatives.

  Sessions typically contain at most a user_id and flash message; both fit
  within the 4K cookie size limit. A CookieOverflow exception is raised if
  you attempt to store more than 4K of data.

  The cookie jar used for storage is automatically configured to be the
  best possible option given your application's configuration.

  If you only have secret_token set, your cookies will be signed, but
  not encrypted. This means a user cannot alter their +user_id+ without
  knowing your app's secret key, but can easily read their +user_id+. This
  was the default for Rails 3 apps.

  If you have secret_key_base set, your cookies will be encrypted. This
  goes a step further than signed cookies in that encrypted cookies cannot
  be altered or read by users. This is the default starting in Rails 4.

  If you have both secret_token and secret_key base set, your cookies will
  be encrypted, and signed cookies generated by Rails 3 will be
  transparently read and encrypted to provide a smooth upgrade path.

  Configure your session store in config/initializers/session_store.rb:

    Rails.application.config.session_store :cookie_store, key: '_your_app_session'

  Configure your secret key in config/secrets.yml:

    development:
      secret_key_base: 'secret key'

  To generate a secret key for an existing application, run `rake secret`.

  If you are upgrading an existing Rails 3 app, you should leave your
  existing secret_token in place and simply add the new secret_key_base.
  Note that you should wait to set secret_key_base until you have 100% of
  your userbase on Rails 4 and are reasonably sure you will not need to
  rollback to Rails 3. This is because cookies signed based on the new
  secret_key_base in Rails 4 are not backwards compatible with Rails 3.
  You are free to leave your existing secret_token in place, not set the
  new secret_key_base, and ignore the deprecation warnings until you are
  reasonably sure that your upgrade is otherwise complete. Additionally,
  you should take care to make sure you are not relying on the ability to
  decode signed cookies generated by your app in external applications or
  JavaScript before upgrading.

  Note that changing the secret key will invalidate all existing sessions!
